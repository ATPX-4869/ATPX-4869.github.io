<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java 基础1.JDK和JRE JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。  2.&#x3D;&#x3D; 和 equals 的区别 &#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的 引用的地址是否相同 ；">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2021/01/22/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java 基础1.JDK和JRE JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。  2.&#x3D;&#x3D; 和 equals 的区别 &#x3D;&#x3D; 对于基本类型来说是值比较，对于引用类型来说是比较的 引用的地址是否相同 ；">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="e:/大学/大三/面试/image/a&f.jpg">
<meta property="article:published_time" content="2021-01-22T07:33:34.000Z">
<meta property="article:modified_time" content="2021-01-22T07:34:42.689Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/大学/大三/面试/image/a&f.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/22/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T07:33:34.000Z" itemprop="datePublished">2021-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-JDK和JRE"><a href="#1-JDK和JRE" class="headerlink" title="1.JDK和JRE"></a>1.JDK和JRE</h2><ul>
<li>JDK：Java Development Kit 的简称，java <strong>开发工具包</strong>，<strong>提供</strong>了 java 的<strong>开发环境</strong>和<strong>运行环境</strong>。</li>
<li>JRE：Java Runtime Environment 的简称，java <strong>运行环境</strong>，<strong>为 java 的运行提供</strong>了<strong>所需环境</strong>。</li>
</ul>
<h2 id="2-和-equals-的区别"><a href="#2-和-equals-的区别" class="headerlink" title="2.== 和 equals 的区别"></a>2.== 和 equals 的区别</h2><p> <strong>==</strong> 对于基本类型来说是<strong>值</strong>比较，对于引用类型来说是比较的 <strong>引用的地址</strong>是否相同 ；</p>
<p> <strong>equals</strong> 默认情况下是<strong>引用比较</strong>，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以<strong>一般情况下</strong> equals 比较的是<strong>值</strong>是否相等。 </p>
<ol>
<li><strong>Object</strong>类的equals（）和==运算符几乎一样，也是要求两个引用类型变量指向同一个对象时才会返回true;</li>
<li><strong>string</strong>类的equals（）已经进行了重写，所以str1.euqals(str2)比较的是str1和str2的<strong>内容</strong>，而不是比较引用类型变量指向的对象<br>此外：</li>
</ol>
<h2 id="3-hashCode-、-equals"><a href="#3-hashCode-、-equals" class="headerlink" title="3.hashCode() 、 equals()"></a>3.hashCode() 、 equals()</h2><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1.hashCode(),str2.hashCode()));</span><br><span class="line">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>哈希值相等，并不一定能得出键值对相等。</p>
<h2 id="4-final-在-Java-中的作用"><a href="#4-final-在-Java-中的作用" class="headerlink" title="4. final 在 Java 中的作用"></a>4. final 在 Java 中的作用</h2><ul>
<li>final 修饰的<strong>类</strong>叫<strong>最终类</strong>，该类<strong>不能被继承</strong>。</li>
<li>final 修饰的<strong>方法 **  **不能被重写</strong>。</li>
<li>final 修饰的<strong>变量</strong>叫<strong>常量</strong>，常量<strong>必须初始化</strong>，初始化之后值就<strong>不能被修改</strong>。</li>
</ul>
<h2 id="5-Math-round-、Math-ceil-、Math-floor"><a href="#5-Math-round-、Math-ceil-、Math-floor" class="headerlink" title="5.Math.round()、Math.ceil()、Math.floor()"></a>5.Math.round()、Math.ceil()、Math.floor()</h2><h4 id="1-Math-round-：将括号内的数-0-5之后，向下取整数，四舍五入"><a href="#1-Math-round-：将括号内的数-0-5之后，向下取整数，四舍五入" class="headerlink" title="(1)Math.round()：将括号内的数+0.5之后，向下取整数，四舍五入"></a>(1)Math.round()：将括号内的数+0.5之后，向下取整数，四舍五入</h4><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Math.round(1.4):&quot;</span>+Math.round(<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.round(1.5):&quot;</span>+Math.round(<span class="number">1.5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.round(-1.4):&quot;</span>+Math.round(-<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.round(-1.5):&quot;</span>+Math.round(-<span class="number">1.5</span>));</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.round(<span class="number">1.4</span>):<span class="number">1</span></span><br><span class="line">Math.round(<span class="number">1.5</span>):<span class="number">2</span></span><br><span class="line">Math.round(-<span class="number">1.4</span>):-<span class="number">1</span></span><br><span class="line">Math.round(-<span class="number">1.5</span>):-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-Math-ceil-求最小的整数-但不小于本身-ceil的英文意义是天花板，该方法就表示向上取整"><a href="#2-Math-ceil-求最小的整数-但不小于本身-ceil的英文意义是天花板，该方法就表示向上取整" class="headerlink" title="(2)Math.ceil():求最小的整数,但不小于本身,ceil的英文意义是天花板，该方法就表示向上取整"></a>(2)Math.ceil():求最小的整数,但不小于本身,ceil的英文意义是天花板，该方法就表示向上取整</h4><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Math.ceil(1.4):&quot;</span>+Math.ceil(<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.ceil(1.5):&quot;</span>+Math.ceil(<span class="number">1.5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.ceil(-1.4):&quot;</span>+Math.ceil(-<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.ceil(-1.5):&quot;</span>+Math.ceil(-<span class="number">1.5</span>));</span><br></pre></td></tr></table></figure>
<p>执行的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(<span class="number">1.4</span>):<span class="number">2.0</span></span><br><span class="line">Math.ceil(<span class="number">1.5</span>):<span class="number">2.0</span></span><br><span class="line">Math.ceil(-<span class="number">1.4</span>):-<span class="number">1.0</span></span><br><span class="line">Math.ceil(-<span class="number">1.5</span>):-<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-Math-floor-求最大的整数-但不大于本身-求最大的整数-但不大于本身"><a href="#3-Math-floor-求最大的整数-但不大于本身-求最大的整数-但不大于本身" class="headerlink" title="(3)Math.floor():求最大的整数,但不大于本身,求最大的整数,但不大于本身"></a>(3)Math.floor():求最大的整数,但不大于本身,求最大的整数,但不大于本身</h4><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Math.floor(1.4):&quot;</span>+Math.floor(<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.floor(1.5):&quot;</span>+Math.floor(<span class="number">1.5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.floor(-1.4):&quot;</span>+Math.floor(-<span class="number">1.4</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Math.floor(-1.5):&quot;</span>+Math.floor(-<span class="number">1.5</span>));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(<span class="number">1.4</span>):<span class="number">1.0</span></span><br><span class="line">Math.floor(<span class="number">1.5</span>):<span class="number">1.0</span></span><br><span class="line">Math.floor(-<span class="number">1.4</span>):-<span class="number">2.0</span></span><br><span class="line">Math.floor(-<span class="number">1.5</span>):-<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<h2 id="6-String-属于基础的数据类型吗"><a href="#6-String-属于基础的数据类型吗" class="headerlink" title="6.String 属于基础的数据类型吗"></a>6.String 属于基础的数据类型吗</h2><p>不是，String属于<strong>对象</strong></p>
<p>JAVA中的八种基本数据类型</p>
<table>
<thead>
<tr>
<th>号</th>
<th>数据类型</th>
<th>位数</th>
<th>默认值</th>
<th>取值范围</th>
<th>举例说明</th>
<th align="center">封装器类</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>byte(位)</td>
<td>8</td>
<td>0</td>
<td>-2^7 - 2^7-1</td>
<td>byte b = 10;</td>
<td align="center">Byte</td>
</tr>
<tr>
<td>2</td>
<td>short(短整数)</td>
<td>16</td>
<td>0</td>
<td>-2^15 - 2^15-1</td>
<td>short s = 10;</td>
<td align="center">Short</td>
</tr>
<tr>
<td>3</td>
<td>int(整数)</td>
<td>32</td>
<td>0</td>
<td>-2^31 - 2^31-1</td>
<td>int i = 10;</td>
<td align="center">Integer</td>
</tr>
<tr>
<td>4</td>
<td>long(长整数)</td>
<td>64</td>
<td>0</td>
<td>-2^63 - 2^63-1</td>
<td>long l = 10l;</td>
<td align="center">Long</td>
</tr>
<tr>
<td>5</td>
<td>float(单精度)</td>
<td>32</td>
<td>0.0</td>
<td>-2^31 - 2^31-1</td>
<td>float f = 10.0f;</td>
<td align="center">Long</td>
</tr>
<tr>
<td>6</td>
<td>double(双精度)</td>
<td>64</td>
<td>0.0</td>
<td>-2^63 - 2^63-1</td>
<td>double d = 10.0d;</td>
<td align="center">Double</td>
</tr>
<tr>
<td>7</td>
<td>char(字符)</td>
<td>16</td>
<td>空</td>
<td>0 - 2^16-1</td>
<td>char c = ‘c’;</td>
<td align="center">Character</td>
</tr>
<tr>
<td>8</td>
<td>boolean(布尔值)</td>
<td>1</td>
<td>false</td>
<td>true、false</td>
<td>boolean b = true</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h2 id="7、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7、java 中操作字符串都有哪些类？它们之间有什么区别？</h2><ul>
<li><p><strong>String：final</strong>修饰,声明的是不可变的对象。每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，</p>
</li>
<li><p><strong>StringBuffer</strong> ：大部分都使用<strong>synchronized</strong>关键字修饰,所以StringBuffer是<strong>线程安全</strong>的</p>
</li>
<li><p><strong>StringBuilder</strong>：<strong>非线程安全</strong>，<strong>性能</strong>却高于 StringBuffer</p>
</li>
</ul>
<p>StringBuffer、StringBuilder 可以在<strong>原有对象</strong>的基础上进行操作，所以在<strong>经常改变字符串内容</strong>的情况下最好不要使用 String。</p>
<p><strong>单线程</strong>环境下推荐使用 <strong>StringBuilder</strong>，<strong>多线程</strong>环境下推荐使用 <strong>StringBuffer</strong>。</p>
<p>执行<strong>速度</strong>:StringBuilder &gt; StringBuffer &gt; String。</p>
<h2 id="8、Strin1g-str-”i”与-String-str-new-String-“i”"><a href="#8、Strin1g-str-”i”与-String-str-new-String-“i”" class="headerlink" title="8、Strin1g str=”i”与 String str=new String(“i”)"></a>8、Strin1g str=”i”与 String str=new String(“i”)</h2><p> String str=”i”的方式，java 虚拟机会将其分配到<strong>常量池</strong>中；</p>
<p> String str=new String(“i”) 则会被分到<strong>堆内存</strong>中。 </p>
<h2 id="9、如何将字符串反转"><a href="#9、如何将字符串反转" class="headerlink" title="9、如何将字符串反转"></a>9、如何将字符串反转</h2><p> 使用 <strong>StringBuilder</strong> 或者 <strong>stringBuffer</strong> 的 <strong>reverse()</strong> 方法。 </p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;stringBuffer.reverse():&quot;</span>+stringBuffer.reverse());</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;stringBuilder.reverse():&quot;</span>+stringBuilder.reverse());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringBuffer.reverse():gfedcba</span><br><span class="line">stringBuilder.reverse():gfedcba</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10、String-类的常用方法"><a href="#10、String-类的常用方法" class="headerlink" title="10、String 类的常用方法"></a>10、String 类的常用方法</h2><ul>
<li><strong>indexOf</strong>()：返回指定字符的<strong>索引</strong>。</li>
<li><strong>charAt</strong>()：返回指定<strong>索引处的字符</strong>。</li>
<li><strong>replace</strong>()：字符串<strong>替换</strong>。</li>
<li><strong>trim</strong>()：<strong>去</strong>除字符串<strong>两端空白</strong>。</li>
<li><strong>split</strong>()：<strong>分割</strong>字符串，返回一个分割后的字符串数组。</li>
<li><strong>getBytes</strong>()：<strong>返回</strong>字符串的 <strong>byte 类型数组</strong>。</li>
<li><strong>length</strong>()：返回字符串<strong>长度</strong>。</li>
<li><strong>toLowerCase</strong>()：将字符串转成<strong>小写</strong>字母。</li>
<li><strong>toUpperCase</strong>()：将字符串转成<strong>大写</strong>字符。</li>
<li><strong>substring</strong>()：<strong>截取</strong>字符串。（顾前不顾后）</li>
<li><strong>equals</strong>()：字符串<strong>比较</strong>。</li>
</ul>
<h2 id="11、抽象类必须要有抽象方法吗？"><a href="#11、抽象类必须要有抽象方法吗？" class="headerlink" title="11、抽象类必须要有抽象方法吗？"></a>11、抽象类必须要有抽象方法吗？</h2><p> 不需要，抽象类不一定非要有抽象方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hey</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;hey!&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 上面代码，抽象类并没有抽象方法但完全可以正常运行 .</p>
<h2 id="12、普通类和抽象类的区别"><a href="#12、普通类和抽象类的区别" class="headerlink" title="12、普通类和抽象类的区别"></a>12、普通类和抽象类的区别</h2><ul>
<li><strong>普通类</strong>不能包含<strong>抽象方法</strong>，抽象类可以包含抽象方法。</li>
<li><strong>抽象类</strong>不能<strong>直接实例化</strong>，普通类可以直接实例化。</li>
</ul>
<h2 id="13、抽象类能使用-final-修饰吗"><a href="#13、抽象类能使用-final-修饰吗" class="headerlink" title="13、抽象类能使用 final 修饰吗"></a>13、抽象类能使用 final 修饰吗</h2><p> 不能，定义<strong>抽象类</strong>就是<strong>让其他类继承</strong>的，如果定义为 <strong>final 该类就不能被继承</strong>，这样彼此就会产生矛盾 </p>
<p><img src="E:\大学\大三\面试\image\a&f.jpg"></p>
<h2 id="14、-接口和抽象类的区别"><a href="#14、-接口和抽象类的区别" class="headerlink" title="14、 接口和抽象类的区别"></a>14、 接口和抽象类的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抽象类</th>
<th align="center">接口类</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>实现</strong></td>
<td align="center">使用 <strong>extends</strong> 来<strong>继承</strong></td>
<td align="center">使用 <strong>implements</strong> 来<strong>实现</strong></td>
</tr>
<tr>
<td align="center"><strong>构造函数</strong></td>
<td align="center"><strong>可以有</strong></td>
<td align="center"><strong>不能有</strong></td>
</tr>
<tr>
<td align="center"><strong>main 方法</strong></td>
<td align="center"><strong>可以有</strong></td>
<td align="center"><strong>不能有</strong></td>
</tr>
<tr>
<td align="center"><strong>实现数量</strong></td>
<td align="center">一个子类只能继承一个父类</td>
<td align="center">一个子类实现多个接口</td>
</tr>
<tr>
<td align="center"><strong>访问修饰符</strong></td>
<td align="center">方法可以是<strong>任意访问修饰符</strong></td>
<td align="center">方法默认使用 <strong>public</strong> 修饰</td>
</tr>
<tr>
<td align="center">相同点</td>
<td align="center">不能被实例化</td>
<td align="center">不能被实例化</td>
</tr>
<tr>
<td align="center"><strong>意义</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li><p>为其他子类提供一个公共的类型</p>
</li>
<li><p>封装子类中重复定义的内容</p>
</li>
<li><p>定义抽象方法,子类虽然有不同的实现,但是定义时一致的 |       <strong>规范,扩展,回调</strong>       |</p>
</li>
</ol>
<h2 id="15、Java-中-IO-流的种类"><a href="#15、Java-中-IO-流的种类" class="headerlink" title="15、Java 中 IO 流的种类"></a>15、Java 中 IO 流的种类</h2><ul>
<li><p>按<strong>功能</strong>来分：<strong>输入流</strong>（input）、<strong>输出流</strong>（output）。</p>
</li>
<li><p>按<strong>类型</strong>来分：<strong>字节流</strong>和<strong>字符流</strong>。</p>
</li>
<li><p>字节流和字符流的<strong>区别</strong>是：<strong>字节流</strong>按 <strong>8 位传输</strong>以<strong>字节为单位</strong>输入输出数据，<strong>字符流</strong>按 <strong>16 位传输</strong>以<strong>字符为单</strong>位输入输出数据。</p>
</li>
</ul>
<h2 id="16、BIO、NIO、AIO的区别"><a href="#16、BIO、NIO、AIO的区别" class="headerlink" title="16、BIO、NIO、AIO的区别"></a>16、BIO、NIO、AIO的区别</h2><ul>
<li><strong>BIO</strong>：Block IO <strong>同步阻塞</strong>式 IO，就是我们平常使用的传统 IO，它的特点是模式<strong>简单</strong>使用<strong>方便</strong>，<strong>并发处理能力低</strong>。</li>
<li><strong>NIO</strong>：New IO <strong>同步非阻塞</strong> IO，是<strong>传统 IO 的升级</strong>，客户端和服务器端通过 <strong>Channel</strong>（通道）通讯，实现了<strong>多路复用</strong>。</li>
<li><strong>AIO</strong>：Asynchronous IO 是 <strong>NIO 的升级</strong>，也叫 <strong>NIO2</strong>，实现了<strong>异步非堵塞</strong> IO ，异步 IO 的操作<strong>基于事件**</strong>和<strong>回调机制</strong>。</li>
</ul>
<h2 id="17、Files的常用方法"><a href="#17、Files的常用方法" class="headerlink" title="17、Files的常用方法"></a>17、Files的常用方法</h2><ul>
<li>Files.<strong>exists</strong>()：检测文件路径<strong>是否存在</strong>。</li>
<li>Files.<strong>createFile</strong>()：<strong>创建</strong>文件。</li>
<li>Files.<strong>createDirectory</strong>()：<strong>创建文件夹</strong>。</li>
<li>Files.<strong>delete</strong>()：<strong>删除一个文件或目录</strong>。</li>
<li>Files.<strong>copy</strong>()：<strong>复制文件</strong>。</li>
<li>Files.<strong>move</strong>()：<strong>移动</strong>文件。</li>
<li>Files.<strong>size</strong>()：<strong>查看文件个数</strong>。</li>
<li>Files.<strong>read</strong>()：<strong>读取</strong>文件。</li>
<li>Files.<strong>write</strong>()：<strong>写入</strong>文件。</li>
</ul>
<h2 id="18、JAVA创建对象的方式"><a href="#18、JAVA创建对象的方式" class="headerlink" title="18、JAVA创建对象的方式"></a>18、JAVA创建对象的方式</h2><ul>
<li><p><strong>new</strong>创建新对象</p>
</li>
<li><p>通过<strong>反射机制</strong></p>
</li>
<li><p>采用<strong>clone机制</strong></p>
</li>
<li><p>通过<strong>序列化机制</strong></p>
<p>前两者都需要显式地调用<strong>构造方法</strong>. </p>
</li>
</ul>
<p>对于clone机制,需要注意<strong>浅拷贝</strong>和<strong>深拷贝</strong>的区别,</p>
<p>序列化可以通过实现<strong>Externalizable</strong>或者<strong>Serializable</strong></p>
<h2 id="19-int和Integer的区别"><a href="#19-int和Integer的区别" class="headerlink" title="19 int和Integer的区别"></a>19 int和Integer的区别</h2><ol>
<li>Integer是int的<strong>包装类</strong>，int则是java的一种基本数据类型</li>
</ol>
<ol start="2">
<li>Integer变量<strong>必须实例化</strong>后<strong>才能使用</strong>，而int变量不需要</li>
</ol>
<ol start="3">
<li>Integer实际是<strong>对象的引用</strong>，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是<strong>直接存储数据值</strong></li>
</ol>
<ol start="4">
<li>Integer的默认值是<strong>null</strong>，int的默认值是<strong>0</strong></li>
</ol>
<h2 id="20-隐式转换和显式转换"><a href="#20-隐式转换和显式转换" class="headerlink" title="20 隐式转换和显式转换"></a>20 隐式转换和显式转换</h2><p><strong>隐式</strong>转换：小的数据类型转换成大的数据类型（<strong>小转大</strong>）</p>
<p><strong>显式</strong>转换：大的数据类型转换成小的数据类型（<strong>大转小</strong>）</p>
<h2 id="21-拆装箱"><a href="#21-拆装箱" class="headerlink" title="21 拆装箱"></a>21 拆装箱</h2><p><strong>装箱</strong>：将<strong>基本数据类型</strong>转换为<strong>包装器类型</strong></p>
<p><strong>拆装</strong>：将<strong>包装器类型</strong>转换为<strong>基本数据类型</strong></p>
<h2 id="22-重写和重载"><a href="#22-重写和重载" class="headerlink" title="22 重写和重载"></a>22 重写和重载</h2><p><strong>重写</strong>：</p>
<p>1.发生在<strong>父类与子类</strong>之间 </p>
<p>2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 </p>
<p>3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) </p>
<p><strong>重载</strong>：</p>
<p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>） </p>
<p>则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来</strong> </p>
<p><strong>判断重载</strong>。 </p>
<h2 id="23-多态"><a href="#23-多态" class="headerlink" title="23 多态"></a>23 多态</h2><p>多态是<strong>同一个行为</strong>具有<strong>多个不同表现形式</strong>或<strong>形态</strong>的能力。</p>
<p>多态就是<strong>同一个接口</strong>，<strong>使用不同的实例</strong>而<strong>执行不同操作</strong>。</p>
<p> 三个必要条件：</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象 </li>
</ul>
<p>表现形式：</p>
<p> <strong>方法重载</strong> ， <strong>方法重写</strong> ，抽象类，接口</p>
<h2 id="24-OOA-OOD-OOP"><a href="#24-OOA-OOD-OOP" class="headerlink" title="24 OOA OOD OOP"></a>24 OOA OOD OOP</h2><p>OOA：面向对象分析</p>
<p>OOD：面向对象设计</p>
<p>OOP：面向对象编程 </p>
<h2 id="25-final-finally-finalize区别"><a href="#25-final-finally-finalize区别" class="headerlink" title="25 final finally finalize区别"></a>25 final finally finalize区别</h2><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li>
</ul>
<ul>
<li><strong>finally</strong>一般作用在<strong>try-catch代码块</strong>中，在处理异常的时候，通常我们将<strong>一定要执行的代码方法放在finally代码块中</strong>，表示不管是否出现异常，该代码块都会执行，一般用来<strong>存放一些关闭资源的代码</strong>。</li>
</ul>
<ul>
<li><strong>finalize</strong>是一个方法，属于Object类的一个方法，而<strong>Object</strong>类是<strong>所有类的父类</strong>，该方法一般<strong>由垃圾回收器来调用</strong>，当我们调用<strong>System.gc()</strong> 方法的时候，由<strong>垃圾回收器调用finalize()**，</strong>回收垃圾**，一个对象是可回收的最后判断。</li>
</ul>
<h2 id="26-this和super的区别"><a href="#26-this和super的区别" class="headerlink" title="26 this和super的区别"></a>26 this和super的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">代表当前对象名</td>
<td align="center">引用当前对象父类中的成员</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">在本类内调用<strong>本类</strong>的其它构造方法</td>
<td align="center">在子类中调用<strong>父类</strong>的构造方法</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">一个指向本对象的<strong>指针</strong></td>
<td align="center">一个Java<strong>关键字</strong></td>
</tr>
</tbody></table>
<ul>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
</ul>
<h2 id="27-static"><a href="#27-static" class="headerlink" title="27 static"></a>27 static</h2><ul>
<li> 意义 ： 创建<strong>独立于</strong>具体<strong>对象</strong>的<strong>变量</strong>或者<strong>方法</strong> ， <strong>没有创建对象，也能使用属性和调用方法</strong>。 </li>
<li> 作用 ： <strong>用来形成静态代码块以优化程序性能</strong> ， 只会在<strong>类加载</strong>的时候<strong>执行一次</strong>。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 </li>
<li>特点：<ol>
<li> 被static修饰的变量或者方法是独立于该类的任何对象 , <strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。 </li>
<li> 在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。 </li>
<li> static变量值在<strong>类加载</strong>的时候<strong>分配空间</strong>，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！ </li>
<li> 被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。 </li>
</ol>
</li>
<li>应用场景： <ol>
<li>修饰成员变量 </li>
<li>修饰成员方法 </li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包 </li>
</ol>
</li>
<li>注意事项：<ol>
<li> 静态只能访问静态</li>
<li> 非静态既可以访问非静态的，也可以访问静态的</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/22/Java%E5%9F%BA%E7%A1%80/" data-id="ckk7z7cw60001jchf0jlscz9s" data-title="Java基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          多线程
        
      </div>
    </a>
  
  
    <a href="/2021/01/22/MyBatis-Plus/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MyBatis-Plus</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/22/Vue%E8%AF%AD%E6%B3%95/">Vue语法</a>
          </li>
        
          <li>
            <a href="/2021/01/22/HashMap/">HashMap</a>
          </li>
        
          <li>
            <a href="/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2021/01/22/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
          </li>
        
          <li>
            <a href="/2021/01/22/MyBatis-Plus/">MyBatis-Plus</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>