<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>多线程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.并发和并行的区别 并发： 两个或多个事件在同一时间间隔发生 。  并行： 指两个或者多个事件在同一时刻发生 。  并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。    2. 线程和进程的区别    线程 进程    根本区别 程序执行的最小单位 资源分配最小单位   地址空间 同一进程的线程共享本进程的地址空间 独立的地址空间   资源拥有 同一进程内的线程共享本进程的资源 独立">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://example.com/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.并发和并行的区别 并发： 两个或多个事件在同一时间间隔发生 。  并行： 指两个或者多个事件在同一时刻发生 。  并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。    2. 线程和进程的区别    线程 进程    根本区别 程序执行的最小单位 资源分配最小单位   地址空间 同一进程的线程共享本进程的地址空间 独立的地址空间   资源拥有 同一进程内的线程共享本进程的资源 独立">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="e:/大学/大三/面试/image/线程池状态.jpg">
<meta property="og:image" content="e:/大学/大三/面试/image/锁.jpg">
<meta property="og:image" content="e:/大学/大三/面试/image/markword.jpg">
<meta property="article:published_time" content="2021-01-22T07:35:23.000Z">
<meta property="article:modified_time" content="2021-01-22T07:40:14.235Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:/大学/大三/面试/image/线程池状态.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T07:35:23.000Z" itemprop="datePublished">2021-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      多线程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-并发和并行的区别"><a href="#1-并发和并行的区别" class="headerlink" title="1.并发和并行的区别"></a>1.并发和并行的区别</h2><ul>
<li><p>并发： 两个或多个事件在同一时间间隔发生 。</p>
</li>
<li><p>并行： 指两个或者多个事件在同一时刻发生 。</p>
</li>
<li><p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 </p>
</li>
</ul>
<h2 id="2-线程和进程的区别"><a href="#2-线程和进程的区别" class="headerlink" title="2. 线程和进程的区别"></a>2. 线程和进程的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">线程</th>
<th align="center">进程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">根本区别</td>
<td align="center">程序执行的最小单位</td>
<td align="center">资源分配最小单位</td>
</tr>
<tr>
<td align="center">地址空间</td>
<td align="center">同一进程的线程共享本进程的地址空间</td>
<td align="center">独立的地址空间</td>
</tr>
<tr>
<td align="center">资源拥有</td>
<td align="center">同一进程内的线程共享本进程的资源</td>
<td align="center">独立资源</td>
</tr>
<tr>
<td align="center">系统开销</td>
<td align="center">开销小</td>
<td align="center">开销大</td>
</tr>
<tr>
<td align="center">影响关系</td>
<td align="center">一个线程崩溃整个进程都死掉</td>
<td align="center">一个进程崩溃，在保护模式下<br />不会对其他进程产生影响</td>
</tr>
</tbody></table>
<h2 id="3-守护线程"><a href="#3-守护线程" class="headerlink" title="3.守护线程"></a>3.守护线程</h2><p> <strong>守护线程</strong>（即daemon thread），是个<strong>服务线程</strong>，准确地来说就是<strong>服务其他的线程</strong>。  是运行在后台的一种特殊进程。它独立于控制终端并且<strong>周期性地执行某种任务</strong>或<strong>等待处理某些发生的事件</strong>。在 Java 中<strong>垃圾回收线程</strong>就是特殊的守护线程。 </p>
<h2 id="4-线程的创建方式"><a href="#4-线程的创建方式" class="headerlink" title="4.线程的创建方式"></a>4.线程的创建方式</h2><p>①. 继承<strong>Thread</strong>类创建线程类</p>
<p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。</p>
<p>②. 通过<strong>Runnable</strong>接口创建线程类</p>
<p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。</p>
<p>③. 通过<strong>Callable</strong>和<strong>Future Task</strong> 创建线程</p>
<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且<strong>有返回值</strong>。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
<h2 id="5-runnable-和-callable-的区别"><a href="#5-runnable-和-callable-的区别" class="headerlink" title="5.runnable 和 callable 的区别"></a>5.<strong>runnable 和 callable</strong> 的区别</h2><ul>
<li><strong>Runnable</strong>接口中的run()方法的返回值是<strong>void</strong>，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li><strong>Callable</strong>接口中的call()方法是<strong>有返回值</strong>的，是一个<strong>泛型</strong>，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
<li>callable 可以看作是 <strong>runnable 的补充</strong> </li>
</ul>
<h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6.线程的状态"></a>6.线程的状态</h2><p><strong>1. 新建状态(New):</strong> 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()</p>
<p><strong>2. 就绪状态(Runnable):</strong> 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的**start()**方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行</p>
<p><strong>3. 运行状态(Running):</strong> 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p>
<p><strong>4. 阻塞状态(Blocked):</strong> 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>(01) <strong>等待</strong>阻塞 – 通过调用线程的**wait()**方法，让线程等待某工作的完成。</li>
<li>(02) <strong>同步</strong>阻塞 – 线程在获取<strong>synchronized</strong>同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>(03) <strong>其他</strong>阻塞 – 通过调用线程的<strong>sleep()**或</strong>join()**或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul>
<p><strong>5. 死亡状态(Dead):</strong> 线程执行完了或者因异常**退出了run()**方法，该线程结束生命周期。</p>
<h2 id="7-sleep-和-wait-的区别"><a href="#7-sleep-和-wait-的区别" class="headerlink" title="7. sleep() 和 wait() 的区别"></a>7. sleep() 和 wait() 的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">sleep()</th>
<th align="center">wait()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">Thread</td>
<td align="center">Object</td>
</tr>
<tr>
<td align="center">锁</td>
<td align="center">不释放锁</td>
<td align="center">释放锁</td>
</tr>
<tr>
<td align="center">用法</td>
<td align="center">时间到会自动恢复</td>
<td align="center">使用 notify()/ notifyAll()直接唤醒</td>
</tr>
</tbody></table>
<h2 id="8-notify-和-notifyAll-的区别"><a href="#8-notify-和-notifyAll-的区别" class="headerlink" title="8. notify()和 notifyAll() 的区别"></a>8. notify()和 notifyAll() 的区别</h2><p> notifyAll()会唤醒<strong>所有的线程</strong>，notify()之后唤醒<strong>一个线程</strong>。notifyAll() 调用后，会将全部线程由<strong>等待池</strong>移到<strong>锁池</strong>，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。 </p>
<h2 id="9-线程的-run-和-start-的区别"><a href="#9-线程的-run-和-start-的区别" class="headerlink" title="9.线程的 run() 和 start() 的区别"></a>9.线程的 run() 和 start() 的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">run()</th>
<th align="center">start()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">功能</td>
<td align="center">执行线程的运行代码</td>
<td align="center">启动线程</td>
</tr>
</tbody></table>
<h2 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10 线程池"></a>10 线程池</h2><ol>
<li>线程池的概念：</li>
</ol>
<p>​        线程池就是首先创建一些线程，它们的<strong>集合</strong>称为线程池。使用线程池可以很好地<strong>提高性能</strong>，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并<strong>不会死亡</strong>，而是再次返回线程池中成为<strong>空闲状态</strong>，等待执行下一个任务。</p>
<ol start="2">
<li>线程池的工作机制</li>
</ol>
<p>​     2.1 在线程池的编程模式下，<strong>任务</strong>是提交给<strong>整个线程池</strong>，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>
<p>​     2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
<ol start="3">
<li>使用线程池的原因：</li>
</ol>
<p>​    多线程运行时间，系统不断的启动和关闭新线程，<strong>成本非常高</strong>，<strong>会过渡消耗系统资源</strong>，以及<strong>过渡切换线程的危险</strong>，从而可能导致系统资源的<strong>崩溃</strong>。这时，线程池就是最好的选择了。</p>
<h2 id="11-线程池的创建方式"><a href="#11-线程池的创建方式" class="headerlink" title="11. 线程池的创建方式"></a>11. 线程池的创建方式</h2><p>①new<strong>Fixed</strong>ThreadPool(int nThreads)</p>
<p>创建一个<strong>固定长度</strong>的线程池，每当<strong>提交一个任务</strong>就<strong>创建一个线程</strong>，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p>②new<strong>Cached</strong>ThreadPool()</p>
<p>创建一个<strong>可缓存</strong>的线程池，如果线程池的<strong>规模超过了处理需求</strong>，将<strong>自动回收空闲线程</strong>，而当<strong>需求增加时</strong>，则可以<strong>自动添加新线程</strong>，线程池的规模不存在任何限制。</p>
<p>③new<strong>Single</strong>Thread<strong>Executor</strong>()</p>
<p>这是一个<strong>单线程的Executor</strong>，它创建<strong>单个工作线程</strong>来执行任务，如果这个线程<strong>异常结束</strong>，会创建一个<strong>新的来替代</strong>它；它的特点是能确保依照任务在队列中的<strong>顺序</strong>来<strong>串行执行</strong>。</p>
<p>④.new<strong>Scheduled</strong>ThreadPool(int corePoolSize)</p>
<p>创建了一个<strong>固定长度</strong>的线程池，而且以<strong>延迟</strong>或<strong>定时</strong>的方式来执行任务，类似于Timer。</p>
<p>⑤ new<strong>WorkStealing</strong>Pool(int parallelism</p>
<p>这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，利用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Work_stealing">Work-Stealing</a>算法，并行地处理任务，<strong>不保证处理顺序</strong>。 </p>
<h2 id="12-线程池的状态"><a href="#12-线程池的状态" class="headerlink" title="12 线程池的状态"></a>12 线程池的状态</h2><p><img src="E:\大学\大三\面试\image\线程池状态.jpg"></p>
<ol>
<li><p>Running： 这是<strong>最正常</strong>的状态，接受新的任务，处理等待队列中的任务 </p>
</li>
<li><p>ShutDown： <strong>不接受新的任务</strong>提交，但是会<strong>继续处理等待队列中的任务</strong>。 </p>
</li>
<li><p>Stop： 不接受新的任务提交，不再处理等待队列中的任务，<strong>中断正在执行任务的线程</strong>。 </p>
</li>
<li><p>Tidying： <strong>所有的任务都销毁</strong>了，<strong>workCount</strong> 为 <strong>0</strong>，线程池的状态在转换为 TIDYING 状态时，会执行<strong>钩子方法</strong> **terminated()**。 </p>
</li>
<li><p>Terminated：  <strong>terminated()方法结束后</strong>，线程池的状态就会变成这个。 </p>
</li>
</ol>
<h2 id="13-线程池中-submit-和-execute-的区别"><a href="#13-线程池中-submit-和-execute-的区别" class="headerlink" title="13 线程池中 submit() 和 execute()的区别"></a>13 线程池中 submit() 和 execute()的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">submit()</th>
<th align="center">execute()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">返回值</td>
<td align="center">有返回值</td>
<td align="center">没有返回值</td>
</tr>
<tr>
<td align="center">定义的接口</td>
<td align="center">ExecutorService</td>
<td align="center">Executor</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="14-在-Java-程序中怎么保证多线程的运行安全"><a href="#14-在-Java-程序中怎么保证多线程的运行安全" class="headerlink" title="14 在 Java 程序中怎么保证多线程的运行安全"></a>14 在 Java 程序中怎么保证多线程的运行安全</h2><ul>
<li>原子性： 一个程序要么完整的被执行,要么完全不执行 ，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
<h2 id="15-多线程锁的升级原理"><a href="#15-多线程锁的升级原理" class="headerlink" title="15  多线程锁的升级原理"></a>15  <strong>多线程锁的升级原理</strong></h2><p><img src="E:\大学\大三\面试\image\锁.jpg"></p>
<p> 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁<strong>可以升级</strong>但<strong>不能降级</strong>。 </p>
<h2 id="16-竞争进程面临三个控制问题"><a href="#16-竞争进程面临三个控制问题" class="headerlink" title="16 竞争进程面临三个控制问题"></a>16 竞争进程面临三个控制问题</h2><p>（1）<strong>互斥</strong>：当一个进程在<strong>临界区</strong>访问共享资源时，其他进程不能进入该临界区访问该资源。<br>（2）<strong>死锁</strong>：两个或两个以上的进程因每个进程都在<strong>等待</strong>其他进程做完某些事情<strong>而不能继续执行</strong>。<br>（3）<strong>饥饿</strong>：一个可运行的进程尽管能继续执行，但<strong>被</strong>调度程序无限期的<strong>忽视</strong>。</p>
<h2 id="17-死锁的条件"><a href="#17-死锁的条件" class="headerlink" title="17 死锁的条件"></a>17 死锁的条件</h2><p>（1）<strong>互斥</strong>：一次只允许一个进程使用一个资源。其他进程不能访问已分配给其他进程的资源。<br>（2）<strong>占有且等待</strong>：当一个进程等待其他进程时，继续占有已分配的资源<br>（3）<strong>不可抢占</strong>：不能强行抢占进程已占有的资源<br>（4）<strong>循环等待</strong>：在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。</p>
<h2 id="18-死锁的预防"><a href="#18-死锁的预防" class="headerlink" title="18 死锁的预防"></a>18 死锁的预防</h2><ul>
<li><strong>间接</strong>预防：防止死锁必要条件前三个中任何一个的发生。</li>
<li><strong>直接</strong>预防：防止循环等待环。</li>
<li>破坏“<strong>互斥</strong>”条件：由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证。</li>
<li>破坏“<strong>占有且等待</strong>”条件：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。 只要有一种资源不能分配，则全部不分配。（缺点：资源浪费）</li>
<li>破坏“<strong>不可抢占</strong>”条件：进程逐个地申请所需资源。当一个已经保持了某些资源的进程申请新资源而不能得到满足时，必须放弃所有已保持的资源。</li>
<li>破坏“<strong>循环等待</strong>”条件：系统将所有资源按类型分配序号并排队；所有进程申请资源必须按序号递增的顺序申请。</li>
</ul>
<h2 id="19-ThreadLocal是什么？有哪些使用场景"><a href="#19-ThreadLocal是什么？有哪些使用场景" class="headerlink" title="19  ThreadLocal是什么？有哪些使用场景"></a>19  ThreadLocal是什么？有哪些使用场景</h2><p>ThreadLocal为每个使用该变量的线程提供独立的<strong>变量副本</strong>，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典<strong>使用场景</strong>是<strong>数据库连接</strong>和 <strong>session 管理</strong>等。</p>
<h2 id="20-临界资源和临界区"><a href="#20-临界资源和临界区" class="headerlink" title="20 临界资源和临界区"></a>20 临界资源和临界区</h2><ul>
<li><strong>临界区</strong>：每个进程中访问临界资源的那段代码</li>
<li><strong>临界资源</strong>：我们把一次只允许一个进程访问的资源</li>
</ul>
<h2 id="21-synchronized-底层实现原理"><a href="#21-synchronized-底层实现原理" class="headerlink" title="21  synchronized 底层实现原理"></a>21  synchronized 底层实现原理</h2><p>synchronized可以保证方法或者代码块在运行时，<strong>同一时刻</strong>只有<strong>一个方法</strong>可以进入到<strong>临界区</strong>，同时它还可以保证<strong>共享变量</strong>的内<strong>存可见性</strong>。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li><strong>普通</strong>同步方法，锁是<strong>当前实例</strong>对象</li>
<li><strong>静态</strong>同步方法，锁是<strong>当前类</strong>的class对象</li>
<li>同步方法<strong>块</strong>，锁是<strong>括号里面</strong>的对象</li>
</ul>
<h2 id="22-synchronized-和-volatile-的区别"><a href="#22-synchronized-和-volatile-的区别" class="headerlink" title="22  synchronized 和 volatile 的区别"></a>22  synchronized 和 volatile 的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">volatile</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本质</td>
<td align="center">锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</td>
<td align="center">告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</td>
</tr>
<tr>
<td align="center">类型</td>
<td align="center">修饰类、方法、代码段</td>
<td align="center">变量修饰符</td>
</tr>
<tr>
<td align="center">阻塞</td>
<td align="center">可能会</td>
<td align="center">不会</td>
</tr>
<tr>
<td align="center">实现变量</td>
<td align="center">保证变量的修改可见性和原子性</td>
<td align="center">修改可见性，不能保证原子性</td>
</tr>
<tr>
<td align="center">使用</td>
<td align="center">变量、方法、和类级别</td>
<td align="center">在变量级别</td>
</tr>
<tr>
<td align="center">标记的变量</td>
<td align="center">可以被编译器优化</td>
<td align="center">不会被编译器优化</td>
</tr>
</tbody></table>
<h2 id="23-synchronized-和-Lock-的区别"><a href="#23-synchronized-和-Lock-的区别" class="headerlink" title="23  synchronized 和 Lock 的区别"></a>23  synchronized 和 Lock 的区别</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存在层次</td>
<td align="center">Java关键字，在JVM层面上</td>
<td align="center">一个Java类</td>
</tr>
<tr>
<td align="center">锁的释放</td>
<td align="center">自动：1.线程执行完同步代码会释放锁<br />2.线程执行过程中发生异常会释放锁</td>
<td align="center">手动：在finally中实现释放锁，否则容易造成线程死锁</td>
</tr>
<tr>
<td align="center">是否获取锁</td>
<td align="center">无法判断</td>
<td align="center">可以判断</td>
</tr>
<tr>
<td align="center">锁类型</td>
<td align="center">重入、不可中断、非公平</td>
<td align="center">可重入、可判断、可公平（两者皆可）</td>
</tr>
<tr>
<td align="center">锁的获取</td>
<td align="center">线程1获得锁，线程2线程等待<br />如果线程1阻塞，线程2则会一直等待下去</td>
<td align="center">而Lock锁就不一定会等待下去，<br />如果尝试获取不到锁，线程可以不用一直等待就结束了</td>
</tr>
<tr>
<td align="center">同步问题</td>
<td align="center">少量</td>
<td align="center">大量</td>
</tr>
</tbody></table>
<h2 id="24-synchronized-和-ReentrantLock-的区别"><a href="#24-synchronized-和-ReentrantLock-的区别" class="headerlink" title="24 synchronized 和 ReentrantLock 的区别"></a>24 synchronized 和 ReentrantLock 的区别</h2><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知 </li>
</ul>
<h2 id="25-atomic-的原理"><a href="#25-atomic-的原理" class="headerlink" title="25 atomic 的原理"></a>25 atomic 的原理</h2><p> atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。  直接操作内存，使用Unsafe 这个类 。 使用 getIntVolatile(var1, var2) 获取线程间共享的变量 。</p>
<h2 id="26-锁"><a href="#26-锁" class="headerlink" title="26 锁"></a>26 锁</h2><h3 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1 悲观锁"></a>1 悲观锁</h3><p>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放</p>
<h3 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2 乐观锁"></a>2 乐观锁</h3><p>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>提交</strong>更新的时候会<strong>判断</strong>一下在此期间别人有没有去更新这个数据。<strong>CAS</strong> 操作实现。</p>
<h3 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3 重量级锁"></a>3 重量级锁</h3><p><strong>Synchronized</strong> 是通过对象内部的一个叫做<strong>监视器锁</strong>（<strong>monitor</strong>）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 <strong>Mutex Lock</strong> 来 实现的。 </p>
<p>而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。 </p>
<p>因此， 这种<strong>依赖</strong>于操作系统 <strong>Mutex Lock</strong> 所实现的<strong>锁</strong>我们称之为“<strong>重量级锁</strong>” 。 JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。 </p>
<p>JDK<strong>1.6</strong> 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“<strong>轻量级锁</strong>”和“<strong>偏向锁</strong>”。</p>
<h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4 轻量级锁"></a>4 轻量级锁</h3><p> 轻量级锁（Lightweight Locking）本意是为了<strong>减少</strong>多线程进入<strong>互斥</strong>(mutex)的几率，并不是要替代互斥。 </p>
<p> <strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。 </p>
<p>顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅<em>将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功</em>，记录锁状态为轻量级锁；<em>否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁</em>。</p>
<h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5 偏向锁"></a>5 偏向锁</h3><p> 锁会偏向于当前已经占有锁的线程 </p>
<p> <strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。 </p>
<p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p>
<p> 偏向锁的实现就是将对象头 markword 的标记设置为偏向，并将线程ID写入对象头 markword，当其他线程请求相同的锁时，偏向模式结束。 </p>
<h3 id="6-可重入锁（递归锁）"><a href="#6-可重入锁（递归锁）" class="headerlink" title="6 可重入锁（递归锁）"></a>6 可重入锁（递归锁）</h3><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。 可重入锁，也叫 做递归锁，指的是<strong>同一线程 外层函数获得锁</strong>之后 ，<strong>内层递归函数仍然有获取该锁的代码</strong>，但不受 影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<h3 id="7-公平锁"><a href="#7-公平锁" class="headerlink" title="7 公平锁"></a>7 <strong>公平锁</strong></h3><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，<strong>先来先得</strong></p>
<h3 id="8-非公平锁"><a href="#8-非公平锁" class="headerlink" title="8 非公平锁"></a>8 <strong>非公平锁</strong></h3><p>加锁时<strong>不考虑排队等待问题</strong>，直接尝试获取锁，获取不到自动到队尾等待 </p>
<ol>
<li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 </p>
</li>
<li><p>Java 中的 synchronized 是非公平锁， ReentrantLock 默认的 lock()方法采用的是非公平锁。 </p>
</li>
</ol>
<h3 id="9-锁模式分"><a href="#9-锁模式分" class="headerlink" title="9 锁模式分"></a>9 锁模式分</h3><p>java 并发包提供的加锁模式分为独占锁和共享锁。 </p>
<h4 id="1独占锁"><a href="#1独占锁" class="headerlink" title="1独占锁"></a>1独占锁</h4><p>独占锁模式下，<strong>每次只能有一个线程能持有锁</strong>， ReentrantLock 就是以独占方式实现的互斥锁。 </p>
<p>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线 </p>
<p>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p>
<h4 id="2共享锁"><a href="#2共享锁" class="headerlink" title="2共享锁"></a>2共享锁</h4><p>共享锁则<strong>允许多个线程同时获取锁</strong>，并发访问 共享资源，如： ReadWriteLock。 共享锁则是一种 </p>
<p>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 </p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等 </li>
</ol>
<p>待线程的锁获取模式。 </p>
<ol start="2">
<li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问， </li>
</ol>
<p>或者被一个 写操作访问，但两者不能同时进行。 </p>
<h3 id="10-锁优化"><a href="#10-锁优化" class="headerlink" title="10 锁优化"></a>10 <strong>锁优化</strong></h3><h4 id="1-减少锁持有时间"><a href="#1-减少锁持有时间" class="headerlink" title="1 减少锁持有时间"></a>1 <strong>减少锁持有时间</strong></h4><p>只用在有线程安全要求的程序上加锁 </p>
<h4 id="2减小锁粒度"><a href="#2减小锁粒度" class="headerlink" title="2减小锁粒度"></a>2<strong>减小锁粒度</strong></h4><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 </p>
<p>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是 </p>
<p>ConcurrentHashMap。 </p>
<h4 id="3-锁分离"><a href="#3-锁分离" class="headerlink" title="3 锁分离"></a>3 <strong>锁分离</strong></h4><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互 </p>
<p>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] </p>
<p>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 </p>
<p>LinkedBlockingQueue 从头部取出，从尾部放数据 </p>
<h4 id="4-锁粗化"><a href="#4-锁粗化" class="headerlink" title="4 锁粗化"></a>4 <strong>锁粗化</strong></h4><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 </p>
<p>公共资源后，应该立即释放锁。但是，凡事都有一个度， 如果对同一个锁不停的进行请求、同步 </p>
<p>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 </p>
<h4 id="5-锁消除"><a href="#5-锁消除" class="headerlink" title="5  锁消除"></a>5  <strong>锁消除</strong></h4><p>锁消除是在编译器级别的事情。 在即时编译器时，如果发现不可能被共享的对象，则可以消除这 </p>
<p>些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<h3 id="11-markword"><a href="#11-markword" class="headerlink" title="11 markword"></a>11 markword</h3><p>HotSpot 虚拟机的对象头包括两部分信息</p>
<ol>
<li><strong>markword</strong>：用于<strong>存储</strong>对象自身的<strong>运行时数据</strong>，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。</li>
<li><strong>klass</strong>：对象<strong>指向</strong>它的类元数据的<strong>指针</strong>，虚拟机通过这个指针来确定这个<strong>对象是哪个类的实例</strong>。</li>
</ol>
<p>markword 数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的最后2bit是锁状态标志位，用来标记当前对象的状态，对象所处的状态，决定了 markword 存储的内容，32位虚拟机在不同状态下 markword 结构如下图所示:</p>
<p><img src="E:\大学\大三\面试\image\markword.jpg"></p>
<h3 id="12-自旋锁"><a href="#12-自旋锁" class="headerlink" title="12 自旋锁"></a>12 自旋锁</h3><p> 那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗。</strong> </p>
<p>但是线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p>JVM 对于自旋周期的选择，jdk1.6前这个限度是一定的写死的，在1.6后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<h2 id="27-线程基本方法"><a href="#27-线程基本方法" class="headerlink" title="27 线程基本方法"></a>27 <strong>线程基本方法</strong></h2><p>线程相关的基本方法有 wait， notify， notifyAll， sleep， join， yield 等。 </p>
<h2 id="28-线程等待（wait）"><a href="#28-线程等待（wait）" class="headerlink" title="28 线程等待（wait）"></a>28 线程等待（wait）</h2><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的 </p>
<p>是调用 wait()方法后， <strong>会释放对象的锁</strong>。因此， wait 方法一般用在同步方法或同步代码块中。  </p>
<h2 id="29-线程睡眠（sleep）"><a href="#29-线程睡眠（sleep）" class="headerlink" title="29 线程睡眠（sleep）"></a>29 线程睡眠（sleep）</h2><p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep <strong>不会释放当前占有的锁</strong>,sleep(long)会导致 </p>
<p>线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态 </p>
<h2 id="30-线程让步（yield）"><a href="#30-线程让步（yield）" class="headerlink" title="30 线程让步（yield）"></a>30 线程让步（yield）</h2><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下， </p>
<p>优先级高的线程有更大的可能性成功竞争得到 CPU 时间片， 但这又不是绝对的，有的操作系统对 </p>
<p>线程优先级并不敏感。  </p>
<h2 id="31-线程中断（interrupt）"><a href="#31-线程中断（interrupt）" class="headerlink" title="31 线程中断（interrupt）"></a>31 线程中断（interrupt）</h2><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个<strong>中断标识位</strong>。 这 </p>
<p>个<strong>线程本身</strong>并<strong>不会因此而改变状态</strong>(如阻塞，终止等)。 </p>
<ol>
<li>调用 <strong>interrupt</strong>()方法并不会中<strong>断一个正在运行的线程</strong>。也就是说处于 Running 状态的 </li>
</ol>
<p>程并不会因为被中断而被终止，仅仅<strong>改变</strong>了内部维护的<strong>中断标识位</strong>而已。 </p>
<ol start="2">
<li>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛 </li>
</ol>
<p>InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 </p>
<ol start="3">
<li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异 </li>
</ol>
<p>常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 </p>
<ol start="4">
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 </li>
</ol>
<p>一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 </p>
<p>根据 thread.isInterrupted()的值来优雅的终止线程。</p>
<h2 id="32-Join-等待其他线程终止"><a href="#32-Join-等待其他线程终止" class="headerlink" title="32 Join 等待其他线程终止"></a>32 Join 等待其他线程终止</h2><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞<br>状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 </p>
<h2 id="33-上下文"><a href="#33-上下文" class="headerlink" title="33 上下文"></a>33 上下文</h2><p>是指某一时间点 CPU 寄存器和程序计数器的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="cklqdfqnb000eiwhfac701azp" data-title="多线程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/22/HashMap/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HashMap
        
      </div>
    </a>
  
  
    <a href="/2021/01/22/Java%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java基础</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/01/%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90/">资料分析</a>
          </li>
        
          <li>
            <a href="/2021/01/22/Vue%E8%AF%AD%E6%B3%95/">Vue语法</a>
          </li>
        
          <li>
            <a href="/2021/01/22/HashMap/">HashMap</a>
          </li>
        
          <li>
            <a href="/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2021/01/22/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>